// every Unit corresponds to a wire in the diagrams
var Unit = function (value, gradient) {
    // value computed in the forward pass
    this.value = value
    // the derivative of the circuit output with respect to this unit, computed in backward pass
    this.gradient = gradient;
}

var multiplyGate = function () { }

multiplyGate.prototype = {
    forward: function (u0, u1) {
        // store pointers to input Units u0 and u1 and output unit utop
        this.u0 = u0;
        this.u1 = u1;
        this.utop = new Unit(u0.value * u1.value, 0.0);
        return this.utop;
    },
    backward: function () {
        // take the gradient in output unit and chain it with the
        // local gradients, which we derived for multiply gate before
        // then write those gradients to those Units.

        // To take the partial derivative with respect to other gates
        // i.e. The output of this gate can be an input of another function

        // We first take the local derivatives of this multiply gate first
        // local partial derivative of this multiply gate w.r.t. to u0
        // = u1
        // local partial derivative of this multiply gate w.r.t. to u1
        // = u0

        // And using the chain rule
        // chain rule = local partial derivative * output circuit derivative
        // partial derivative for the whole circuit w.r.t u0
        // = u1 * output circuit derivative
        // partial derivative for the whole circuit w.r.t u1
        // = u0 * output circuit derivative
        // this.utop represents the ouput wire so
        // output circuit derivative = this.utop.gradient
        this.u0.gradient += this.u1.value * this.utop.gradient;
        this.u1.gradient += this.u0.value * this.utop.gradient;
    }
}

var addGate = function () { }
addGate.prototype = {
    forward: function (u0, u1) {
        this.u0 = u0;
        this.u1 = u1;
        this.utop = new Unit(u0.value + u1.value, 0.0);
        return this.utop;
    },
    backward: function () {
        // add gate. derivative wrt both inputs is 1
        this.u0.gradient += 1 * this.utop.gradient;
        this.u1.gradient += 1 * this.utop.gradient;
    }
}

var sigmoidGate = function () {
    // helper function
    this.sig = function (x) { return 1 / (1 + Math.exp(-x)) };
}

sigmoidGate.prototype = {
    forward: function (u0) {
        this.u0 = u0;
        this.utop = new Unit(this.sig(this.u0.value), 0.0);
        return this.utop;
    },
    backward: function () {
        var s = this.sig(this.u0.value)
        this.u0.gradient += (s * (1 - s)) * this.utop.gradient;
    }
}

// create input units
var a = new Unit(1.0, 0.0);
var b = new Unit(2.0, 0.0);
var c = new Unit(-3.0, 0.0);
var x = new Unit(-1.0, 0.0);
var y = new Unit(3.0, 0.0);
var s;

// Create the gates
var mulg0 = new multiplyGate();
var mulg1 = new multiplyGate();
var addg0 = new addGate();
var addg1 = new addGate();
var sg0 = new sigmoidGate();

// do the forward pass
var forwardNeuron = function () {
    ax = mulg0.forward(a, x);
    by = mulg1.forward(b, y);
    ax_plus_by = addg0.forward(ax, by);
    ax_plus_by_plus_c = addg1.forward(ax_plus_by, c);
    s = sg0.forward(ax_plus_by_plus_c);
}

forwardNeuron();
console.log('circuit output: ', s.value)

// Let's do compute the gradients for each input
// the backward flow
s.gradient = 1.0
sg0.backward(); // writes gradient to ax_plus_by_plus_c
addg1.backward(); // writes gradient to ax_plus_by and c
addg0.backward(); // writes gradient for ax and by
mulg1.backward(); // writes gradient for b and y
mulg0.backward(); // writes gradients for a and x

// Now that we have the gradients, for each input
// let's increase the output
var step_size = 0.01
a.value += step_size * a.gradient;
b.value += step_size * b.gradient;
c.value += step_size * c.gradient;
x.value += step_size * x.gradient;
y.value += step_size * y.gradient;

forwardNeuron();
console.log('circuit output after one backpropagation: ', s.value);

// Let's verify that the gradients generated by the backpropagation is correct
//  σ(a,b,c,x,y) = 1 / 1 + e ^ -(ax + by + c)
//  ∂σ(a,b,c,x,y) / a = σ(a+h,b,c,x,y) - σ(a,b,x,y,c) / h
//  ∂σ(a,b,c,x,y) / b = σ(a,b+h,c,x,y) - σ(a,b,x,y,c) / h
//  ∂σ(a,b,c,x,y) / c = σ(a,b,c+h,x,y) - σ(a,b,x,y,c) / h
//  ∂σ(a,b,c,x,y) / x = σ(a,b,c,x+h,y) - σ(a,b,x,y,c) / h
//  ∂σ(a,b,c,x,y) / y = σ(a,b,c,x,y+h) - σ(a,b,x,y,c) / h

var forwardCircuitFast = function (a, b, c, x, y) {
    return 1 / (1 + Math.exp(- (a * x + b * y + c)));
};
var a = 1, b = 2, c = -3, x = -1, y = 3;
var h = 0.0001;
var a_grad = (forwardCircuitFast(a + h, b, c, x, y) - forwardCircuitFast(a, b, c, x, y)) / h;
var b_grad = (forwardCircuitFast(a, b + h, c, x, y) - forwardCircuitFast(a, b, c, x, y)) / h;
var c_grad = (forwardCircuitFast(a, b, c + h, x, y) - forwardCircuitFast(a, b, c, x, y)) / h;
var x_grad = (forwardCircuitFast(a, b, c, x + h, y) - forwardCircuitFast(a, b, c, x, y)) / h;
var y_grad = (forwardCircuitFast(a, b, c, x, y + h) - forwardCircuitFast(a, b, c, x, y)) / h;

console.log('The gradients are: ', [a_grad, b_grad, c_grad, x_grad, y_grad]);